(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{343:function(t,s,n){"use strict";n.r(s);var r=n(14),a=Object(r.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"线程的活性故障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的活性故障"}},[this._v("#")]),this._v(" 线程的活性故障")]),this._v(" "),t("p",[this._v("线程是为任务而生的。理想情况下我们希望线程一直处于RUNNABLE状态。但事实并非如此，导致一个线程可能处于非RUNNABLE状态的因素除了资源限制之外，既主要是处理器资源有限而导致的上下文切换，还有程序自身的错误和缺陷。这些由于资源稀缺性及程序自身的问题导致线程一直处于非RUNNABLE状态，或者线程处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被成为线程活性故障。常见的线程活性故障有：1.死锁：死锁好比鹬蚌相争，一个线程X持有资源A的时候等待另一个线程释放资源B,而另外一个线程Y持有资源B等待另一个线程释放资源A。这样就会导致线程的生命周期永远处于非RUNNABLE状态而使其任务无法取得进展；2.锁死：锁死好比睡美人故事中睡美人醒来的前提是她要得到王子的亲吻，但是如果王子无法亲吻她，那么睡美人就一直沉睡。3.活锁：好比小猫咬自己的尾巴，虽然它总是追着自己的尾巴咬，但却始终无法咬到。活锁会导致线程所要执行的任务丝毫没有进展，线程一直在做无用功。4：饥饿：线程饥饿好比母鸟给雏鸟喂食，强壮的雏鸟总是抢先从母鸟的嘴中抢到食物，从而导致弱小的雏鸟总是挨饿。线程饥饿就是线程无法获取资源而使得任务执行无法进展的现象。")])])}),[],!1,null,null,null);s.default=a.exports}}]);